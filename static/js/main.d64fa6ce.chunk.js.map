{"version":3,"sources":["DirectorMode.js","components/Canvas.js","App.js","serviceWorker.js","index.js"],"names":["DirectorMode","el","canvas","document","querySelector","this","ctx","getContext","Error","actors","editing","dragging","mousedown","res","offsetX","offsetY","vOffsetX","vOffsetY","vMaxOffsetX","vMaxOffsetY","anchorX","anchorY","scale","minScale","maxScale","addEventListener","e","preventDefault","loc","windowToCanvas","clientX","clientY","locNormalized","x","normalizeX","y","normalizeY","console","debug","selected","scene","forEach","actor","isPointInActor","call","anchor","startDragging","removeActor","addActor","dragOffsetX","dragOffsetY","dragCallback","round","runCycle","prevLoc","dtX","dtY","onSelect","cursor","onDrag","colliding","actorsInPoint","length","deltaY","window","canvasFocus","target","keyCode","css","style","state","color","stepX","stepY","save","strokeStyle","lineWidth","width","height","startX","startY","i","beginPath","moveTo","lineTo","stroke","restore","clearRect","bbox","getBoundingClientRect","left","top","drawVerticalLine","drawHorizontalLine","index","indexOf","splice","push","sprite","render","texture","drawImage","radius","drawActor","w","h","rect","clearCanvas","translate","drawGrid","drawActors","drawBorder","drawGuidewires","src","loaded","error","img","Image","fileName","cb","createImage","path","filter","loadResources","clone","Object","create","number","Math","toFixed","squared","isPointInCircle","isPointInRect","num","pow","Container","styled","div","margin","textAlign","display","Preview","CanvasContainer","Canvas","running","ref","director","directorInstance","getCurrentScene","loadScene","log","previewRef","scenes","props","data","selectedIndex","nextState","visibility","Game","Runner","addMouseConstraint","run","removeChild","children","setState","nextProps","preview","setupCanvas","setupPreview","React","Component","require","App","useState","setRunning","className","onClick","Boolean","location","hostname","match","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.d64fa6ce.chunk.js","sourcesContent":["export default class DirectorMode {\r\n  constructor(el) {\r\n    let canvas = typeof el === 'string' ? document.querySelector(el) : el;\r\n    this.ctx = canvas.getContext('2d');\r\n\r\n    if (!canvas || !this.ctx) throw new Error({'Error': 'Canvas element not found.'});\r\n\r\n    this.actors = [];\r\n    this.editing = true;\r\n    this.dragging = false;\r\n    this.mousedown = {};\r\n    this.res = {};\r\n    this.offsetX = 0;\r\n    this.offsetY = 0;\r\n    this.vOffsetX = 0;\r\n    this.vOffsetY = 0;\r\n    this.vMaxOffsetX = 20;\r\n    this.vMaxOffsetY = 20;\r\n    this.anchorX = 0.5;\r\n    this.anchorY = 0.5;\r\n    this.scale = 1;\r\n    this.minScale = 0.5;\r\n    this.maxScale = 4;\r\n\r\n    canvas.addEventListener('mousedown', e => {\r\n      e.preventDefault();\r\n      const loc = this.windowToCanvas(e.clientX, e.clientY);\r\n      const locNormalized = { x: this.normalizeX(loc.x), y: this.normalizeY(loc.y) };\r\n\r\n      console.debug('mousedown', loc);\r\n      console.debug('mousedown (normalized)', locNormalized);\r\n      console.debug(`normalize debug | offsetX: ${this.offsetX} scale: ${this.scale}`);\r\n\r\n      this.selected = null;\r\n      this.scene.actors.forEach(actor => {\r\n        if (isPointInActor.call(this, loc.x, loc.y, this.anchor(actor))) {\r\n          this.startDragging(loc);\r\n          this.removeActor(actor);\r\n          this.addActor(actor);\r\n\r\n          // this.selected = actor;\r\n          // this.dragging = actor;\r\n          this.selected = actor;\r\n          this.dragging = actor;\r\n          // this.dragOffsetX = (loc.x - actor.x)/this.scale;\r\n          // this.dragOffsetY = (loc.y - actor.y)/this.scale;\r\n          this.dragOffsetX = this.normalizeX(loc.x) - actor.x;\r\n          this.dragOffsetY = this.normalizeY(loc.y) - actor.y;\r\n          // this.dragOffsetX = (loc.x)/this.scale - actor.x;\r\n          // this.dragOffsetY = (loc.y)/this.scale - actor.y;\r\n          // this.dragOffsetX = this.normalizeX(loc.x - actor.x);\r\n          // this.dragOffsetY = this.normalizeY(loc.y - actor.y);\r\n          this.dragCallback = function(loc) {\r\n            // this.selected.x = this.round(loc.x - this.dragOffsetX)/this.scale;\r\n            // this.selected.y = this.round(loc.y - this.dragOffsetY)/this.scale;\r\n            // this.selected.x = this.round(loc.x/this.scale - this.dragOffsetX);\r\n            // this.selected.y = this.round(loc.y/this.scale - this.dragOffsetY);\r\n            this.selected.x = this.round(this.normalizeX(loc.x) - this.dragOffsetX);\r\n            this.selected.y = this.round(this.normalizeY(loc.y) - this.dragOffsetY);\r\n          };\r\n          this.runCycle();\r\n        }\r\n        else {\r\n          this.dragging = true;\r\n          this.prevLoc = loc;\r\n          this.dragCallback = function(loc) {\r\n            let dtX = (loc.x - this.prevLoc.x)/this.scale;\r\n            let dtY = (loc.y - this.prevLoc.y)/this.scale;\r\n            this.offsetX += dtX;\r\n            this.offsetY += dtY;\r\n            this.prevLoc = loc;\r\n          };\r\n        }\r\n        if(this.onSelect) this.onSelect(this.selected, loc);\r\n      });\r\n    });\r\n\r\n    canvas.addEventListener('mousemove', e => {\r\n      e.preventDefault(); // prevent selections\r\n      let loc = this.windowToCanvas(e.clientX, e.clientY);\r\n      if (this.editing && this.dragging) {\r\n        this.cursor('all-scroll');\r\n        this.dragCallback(loc);\r\n        this.runCycle();\r\n        if(this.onDrag) this.onDrag();\r\n        return;\r\n      }\r\n\r\n      let colliding = this.actorsInPoint(loc.x, loc.y);\r\n      this.cursor('auto');\r\n      if (colliding.length > 0) {\r\n        this.cursor('pointer');\r\n      }\r\n\r\n      // this.scene.actors.forEach(actor => {\r\n      // \tif (isPointInActor(this.normalizeX(loc.x), this.normalizeY(loc.y), actor)) {\r\n      // \t\tthis.cursor('pointer');\r\n      // \t} else {\r\n      // \t\tthis.cursor('auto');\r\n      // \t}\r\n      // });\r\n    });\r\n\r\n    canvas.addEventListener('mouseup', e => {\r\n      this.dragging = false;\r\n    });\r\n\r\n    canvas.addEventListener('mousewheel', e => {\r\n      e.preventDefault();\r\n\r\n      if (e.deltaY > 0) {\r\n        if (!(this.scale - 0.1 < this.minScale))\r\n          this.scale -= 0.1;\r\n      } else {\r\n        if (!(this.scale + 0.1 > this.maxScale))\r\n          this.scale += 0.1;\r\n      }\r\n\r\n      this.runCycle();\r\n    });\r\n\r\n    window.addEventListener('mousedown', e =>{\r\n      this.canvasFocus = e.target == canvas;\r\n    });\r\n\r\n    window.addEventListener('keydown', e => {\r\n      if (!this.canvasFocus) return;\r\n\r\n      this.vOffsetX += this.vOffsetX < this.vMaxOffsetX ? 1 : 0;\r\n\r\n      if(this.selected) {\r\n        if (e.keyCode === 37) { // left\r\n          this.selected.x -= this.vOffsetX;\r\n        } else if (e.keyCode === 39) { // right\r\n          this.selected.x += this.vOffsetX;\r\n        }\r\n      }\r\n      else {\r\n        if (e.keyCode === 37) { // left\r\n          this.offsetX -= this.vOffsetX;\r\n        } else if (e.keyCode === 39) { // right\r\n          this.offsetX += this.vOffsetX;\r\n        }\r\n      }\r\n      this.runCycle();\r\n      if (this.onDrag) this.onDrag();\r\n    });\r\n\r\n    window.addEventListener('keyup', e => {\r\n      if (!this.canvasFocus) return;\r\n      this.vOffsetX = this.vOffsetY = 0;\r\n    });\r\n  }\r\n\r\n  get width() {\r\n    return this.ctx.canvas.width;\r\n  }\r\n\r\n  get height() {\r\n    return this.ctx.canvas.height;\r\n  }\r\n\r\n  cursor(cursor) {\r\n    var css = this.ctx.canvas.style;\r\n    return cursor ? css.cursor = cursor : css.cursor;\r\n  }\r\n\r\n  setState(state) {\r\n    this.state = state;\r\n  }\r\n\r\n  isState(state) {\r\n    return this.state === state;\r\n  }\r\n\r\n  drawGrid(color = 'lightgrey', stepX = 25, stepY = 25) {\r\n    this.ctx.save();\r\n    this.ctx.strokeStyle = color;\r\n    this.ctx.lineWidth = 0.5;\r\n\r\n    const width = this.width/this.scale;\r\n    const height = this.height/this.scale;\r\n\r\n    const startX = this.offsetX % stepX;\r\n    const startY = this.offsetY % stepY;\r\n\r\n    for (let i = startX + 0.5; i < width; i += stepX) {\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(i - this.offsetX, 0 - this.offsetY);\r\n      this.ctx.lineTo(i - this.offsetX, height - this.offsetY);\r\n      this.ctx.stroke();\r\n    }\r\n\r\n    for (let i = startY + 0.5; i < height; i += stepY) {\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(0 - this.offsetX, i - this.offsetY);\r\n      this.ctx.lineTo(width - this.offsetX, i - this.offsetY);\r\n      this.ctx.stroke();\r\n    }\r\n\r\n    this.ctx.restore();\r\n  }\r\n  clearCanvas() {\r\n    this.ctx.clearRect(0, 0, this.width, this.height);\r\n  }\r\n  startDragging(loc) {\r\n    this.mousedown.x = loc.x;\r\n    this.mousedown.y = loc.y;\r\n  }\r\n  windowToCanvas(x, y) {\r\n    const canvas = this.ctx.canvas;\r\n    var bbox = canvas.getBoundingClientRect();\r\n    return { x: x - bbox.left * (canvas.width  / bbox.width),\r\n             y: y - bbox.top  * (canvas.height / bbox.height) };\r\n  }\r\n  drawHorizontalLine (y) {\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(0 - this.offsetX, y+0.5);\r\n    this.ctx.lineTo(0 - this.offsetX + this.width/this.scale, y+0.5);\r\n    this.ctx.stroke();\r\n  }\r\n  drawVerticalLine  (x) {\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(x+0.5, 0 - this.offsetY);\r\n    this.ctx.lineTo(x+0.5, 0 - this.offsetY + this.height/this.scale);\r\n    this.ctx.stroke();\r\n  }\r\n  drawGuidewires(x, y) {\r\n    this.ctx.save();\r\n    this.ctx.strokeStyle = 'rgba(0,0,230,0.4)';\r\n    this.ctx.lineWidth = 0.5;\r\n    this.drawVerticalLine(x);\r\n    this.drawHorizontalLine(y);\r\n    this.ctx.restore();\r\n  }\r\n  removeActor(actor) {\r\n    const index = this.scene.actors.indexOf(actor);\r\n    if (index != -1) this.scene.actors.splice(index, 1);\r\n  }\r\n  addActor(actor) {\r\n    this.scene.actors.push(actor);\r\n  }\r\n  drawActor(actor) {\r\n    const sprite = this.res[actor.render.sprite.texture];\r\n    actor = this.anchor(actor);\r\n    this.ctx.drawImage(sprite, actor.x, actor.y, actor.width || actor.radius*2, actor.height || actor.radius*2);\r\n    // this.ctx.drawImage(sprite, actor.x - (actor.width * this.anchorX), actor.y - (actor.height * this.anchorY), actor.width || actor.radius*2, actor.height || actor.radius*2);\r\n  }\r\n  drawActors() {\r\n    this.scene.actors.forEach(actor => {\r\n      this.drawActor(actor);\r\n    });\r\n  }\r\n  drawBorder(x, y, w, h) {\r\n    this.ctx.save();\r\n    this.ctx.lineWidth = 2;\r\n    this.ctx.strokeStyle = 'red';\r\n    this.ctx.beginPath();\r\n    this.ctx.rect(x-1, y-1, w+2, h+2);\r\n    this.ctx.stroke();\r\n    this.ctx.restore();\r\n  }\r\n  runCycle() {\r\n    this.clearCanvas();\r\n    this.ctx.save();\r\n    this.ctx.scale(this.scale, this.scale);\r\n    this.ctx.translate(this.offsetX, this.offsetY);\r\n    this.drawGrid('lightgray', 25, 25);\r\n    this.drawActors();\r\n    if(this.selected) {\r\n      const selected = this.anchor(this.selected);\r\n      // this.drawBorder(this.selected.x, this.selected.y, this.selected.width, this.selected.height);\r\n      this.drawBorder(selected.x, selected.y, selected.width || selected.radius*2, selected.height || selected.radius*2);\r\n      this.drawGuidewires(selected.x + (selected.width/2 || selected.radius), selected.y + (selected.height/2 || selected.radius) );\r\n      // this.drawGuidewires(this.selected.x+this.selected.width/2,\r\n      // \t\t\t\t\t\t\t\t\t  this.selected.y+this.selected.height/2);\r\n    }\r\n    this.ctx.restore();\r\n  }\r\n  createImage(src, loaded, error) {\r\n    let img = new Image();\r\n    img.src = img.fileName = src;\r\n    img.addEventListener('load', loaded);\r\n    img.addEventListener('error', error);\r\n\r\n    return img;\r\n  }\r\n  loadResources(cb) {\r\n    let res = this.scene.res;\r\n    res.forEach(fileName => {\r\n      this.res[fileName] = this.createImage(fileName, e => {\r\n        if(res.indexOf(e.path[0].fileName) == (res.length -1))\r\n          this.runCycle();\r\n      });\r\n    });\r\n    // let images = Data.res;\r\n    // for(let i = 0; i < images.length; i++) {\r\n    //   var fileName = images[i];\r\n    //   let img = createImage(src, e => {\r\n    //     if(images.indexOf(e.path[0].fileName) == images.length -1) cb()\r\n    //   });\r\n    //   this.images[fileName] = img;\r\n    // }\r\n  }\r\n  actorsInPoint(x, y) {\r\n    let arr = this.scene.actors.filter(actor => isPointInActor.call(this, x, y, this.anchor(actor)));\r\n\r\n    // if (arr.length == 1) arr = arr[0];\r\n    return arr;\r\n  }\r\n  loadScene(scene) {\r\n    this.scene = scene;\r\n    this.loadResources();\r\n    this.runCycle();\r\n\r\n  }\r\n  anchor(actor) {\r\n    let clone = Object.create(actor);\r\n    clone.x = actor.x - (actor.width || actor.radius*2) * this.anchorX;\r\n    clone.y = actor.y - (actor.height || actor.radius*2) * this.anchorY;\r\n\r\n    if (actor.radius) {\r\n      // clone.x = actor.x - (actor.width || actor.radius*2) * this.anchorX;\r\n      // clone.y = actor.y - (actor.height || actor.radius*2) * this.anchorY;\r\n      // console.log('compare radius', actor, clone);\r\n    }\r\n\r\n    // const diff = {\r\n    // x: actor.x - (actor.width || actor.radius) * this.anchorX,\r\n    // y: actor.y - (actor.height || actor.radius) * this.anchorY\r\n    // };\r\n    // return Object.assign(actor, diff);\r\n    return clone;\r\n  }\r\n  normalizeX(x) {\r\n    return (x - this.offsetX)/this.scale;\r\n    // return (x - this.offsetX)/this.scale;\r\n  }\r\n  normalizeY(y) {\r\n    return (y - this.offsetY)/this.scale;\r\n    // return (y - this.offsetY)/this.scale;\r\n  }\r\n\r\n  round(number) {\r\n    return +(Math.round(number * 2) / 2).toFixed(1)\r\n  }\r\n}\r\n\r\nfunction isPointInActor(x, y, actor) {\r\n  x = x/this.scale - this.offsetX;\r\n  y = y/this.scale - this.offsetY;\r\n\r\n  if (actor.radius) {\r\n    return isPointInCircle(x, y, actor);\r\n  }\r\n\r\n  if (actor.width && actor.height) {\r\n    return isPointInRect(x, y, actor);\r\n  }\r\n}\r\n\r\nfunction isPointInCircle(x, y, actor) {\r\n  if (!actor.radius) return false;\r\n\r\n  const distance = squared(x - (actor.x + actor.radius)) + squared(y - (actor.y + actor.radius));\r\n  return distance <= squared(actor.radius);\r\n}\r\n\r\nfunction isPointInRect(x, y, actor) {\r\n  if (!actor.width && !actor.height) return false;\r\n\r\n  return (!(x < actor.x || x > actor.x+actor.width) &&\r\n          !(y < actor.y || y > actor.y+actor.height));\r\n}\r\n\r\nfunction squared(num) {\r\n  return Math.pow(num, 2);\r\n}\r\n","import React from 'react';\r\nimport styled from 'styled-components';\r\nimport Runner from 'kurupira-runner';\r\nimport DirectorMode from '../DirectorMode';\r\n\r\nconst Container = styled.div({\r\n  height: 400,\r\n  width: 600,\r\n  margin: 20,\r\n  textAlign: 'center',\r\n  display: 'inline-block',\r\n});\r\n\r\nconst Preview = styled.div`\r\n  width: 600px;\r\n  height: 400px;\r\n  visibility: hidden;\r\n  overflow: hidden;\r\n`;\r\n\r\nconst CanvasContainer = styled.div`\r\n  position: relative;\r\n  width: 600px;\r\n  height: 400px;\r\n\r\n  > * {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n  }\r\n`;\r\n\r\n\r\nclass Canvas extends React.Component {\r\n  constructor () {\r\n    super();\r\n    this.state = { running: false };\r\n  }\r\n\r\n  setupCanvas(ref) {\r\n    if (!ref)\r\n      return null;\r\n\r\n    const director = this.directorInstance = new DirectorMode(ref);\r\n\r\n    //  director.runCycle();\r\n    const scene = this.getCurrentScene();\r\n    director.loadScene(scene);\r\n    director.onSelect = (actor) => {\r\n      console.log(actor);\r\n    };\r\n\r\n    director.onDrag = () => {\r\n    };\r\n  }\r\n\r\n  setupPreview(ref) {\r\n    this.previewRef = ref;\r\n  }\r\n\r\n  getCurrentScene() {\r\n    const { scenes } = this.props;\r\n    const { data, selectedIndex } = scenes;\r\n    return data[selectedIndex];\r\n  }\r\n\r\n  preview() {\r\n    const { running } = this.state\r\n    const { previewRef } = this;\r\n    const nextState = !running;\r\n\r\n    previewRef.style.visibility = nextState ? 'unset' : 'hidden';\r\n\r\n    if (nextState) {\r\n      const scene = this.getCurrentScene();\r\n      const Game = new Runner(scene, this.previewRef);\r\n      Game.addMouseConstraint();\r\n      Game.run();\r\n    } else {\r\n      previewRef.removeChild(previewRef.children[0])\r\n    }\r\n\r\n    this.setState({ running: nextState });\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps) {\r\n    if (this.props.running !== nextProps.running)\r\n      this.preview();\r\n    return false;\r\n  }\r\n\r\n  render() {\r\n    const { running } = this.state;\r\n    return (\r\n      <Container>\r\n        <CanvasContainer running={running}>\r\n          <canvas width=\"600\" height=\"400\" ref={ref => this.setupCanvas(ref)}>\r\n            no support\r\n          </canvas>\r\n          <Preview ref={ref => this.setupPreview(ref)}>\r\n\r\n          </Preview>\r\n        </CanvasContainer>\r\n      </Container>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Canvas;\r\n","import React from 'react';\r\nimport Canvas from './components/Canvas.js';\r\n\r\nimport './App.css';\r\nconst scenes = require('./model.json');\r\n\r\n\r\nfunction App() {\r\n\tconst [running, setRunning] = React.useState(false);\r\n\r\n\treturn (\r\n\t\t<div className=\"App\">\r\n\t\t\t<Canvas scenes={{ data: [scenes], selectedIndex: 0 }} running={running} />\r\n\t\t\t<div>\r\n\t\t\t\t<button onClick={() => setRunning(!running)}>\r\n\t\t\t\t\t{ running ? 'Stop' : 'Run' }\r\n\t\t\t\t</button>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}